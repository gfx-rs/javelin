fn main1() {
    var a: vec4<f32> = vec4<f32>(1.0, 1.0, 1.0, 1.0);
    var b: vec4<f32> = vec4<f32>(2.0, 2.0, 2.0, 2.0);
    var m: mat4x4<f32>;
    var i: i32 = 5;
    var ceilOut: vec4<f32>;
    var roundOut: vec4<f32>;
    var floorOut: vec4<f32>;
    var fractOut: vec4<f32>;
    var truncOut: vec4<f32>;
    var sinOut: vec4<f32>;
    var absOut: vec4<f32>;
    var sqrtOut: vec4<f32>;
    var inversesqrtOut: vec4<f32>;
    var expOut: vec4<f32>;
    var exp2Out: vec4<f32>;
    var signOut: vec4<f32>;
    var transposeOut: mat4x4<f32>;
    var normalizeOut: vec4<f32>;
    var sinhOut: vec4<f32>;
    var cosOut: vec4<f32>;
    var coshOut: vec4<f32>;
    var tanOut: vec4<f32>;
    var tanhOut: vec4<f32>;
    var acosOut: vec4<f32>;
    var asinOut: vec4<f32>;
    var logOut: vec4<f32>;
    var log2Out: vec4<f32>;
    var lengthOut: f32;
    var determinantOut: f32;
    var bitCountOut: i32;
    var bitfieldReverseOut: i32;
    var atanOut: f32;
    var atan2Out: f32;
    var modOut: f32;
    var powOut: vec4<f32>;
    var dotOut: f32;
    var maxOut: vec4<f32>;
    var minOut: vec4<f32>;
    var reflectOut: vec4<f32>;
    var crossOut: vec3<f32>;
    var outerProductOut: mat4x4<f32>;
    var distanceOut: f32;
    var stepOut: vec4<f32>;

    let _e6: vec4<f32> = a;
    let _e7: vec4<f32> = b;
    let _e8: vec4<f32> = a;
    let _e9: vec4<f32> = b;
    m = mat4x4<f32>(_e6, _e7, _e8, _e9);
    let _e14: vec4<f32> = a;
    ceilOut = ceil(_e14);
    let _e17: vec4<f32> = a;
    roundOut = round(_e17);
    let _e20: vec4<f32> = a;
    floorOut = floor(_e20);
    let _e23: vec4<f32> = a;
    fractOut = fract(_e23);
    let _e26: vec4<f32> = a;
    truncOut = trunc(_e26);
    let _e29: vec4<f32> = a;
    sinOut = sin(_e29);
    let _e32: vec4<f32> = a;
    absOut = abs(_e32);
    let _e35: vec4<f32> = a;
    sqrtOut = sqrt(_e35);
    let _e38: vec4<f32> = a;
    inversesqrtOut = inverseSqrt(_e38);
    let _e41: vec4<f32> = a;
    expOut = exp(_e41);
    let _e44: vec4<f32> = a;
    exp2Out = exp2(_e44);
    let _e47: vec4<f32> = a;
    signOut = sign(_e47);
    let _e50: mat4x4<f32> = m;
    transposeOut = transpose(_e50);
    let _e53: vec4<f32> = a;
    normalizeOut = normalize(_e53);
    let _e56: vec4<f32> = a;
    sinhOut = sinh(_e56);
    let _e59: vec4<f32> = a;
    cosOut = cos(_e59);
    let _e62: vec4<f32> = a;
    coshOut = cosh(_e62);
    let _e65: vec4<f32> = a;
    tanOut = tan(_e65);
    let _e68: vec4<f32> = a;
    tanhOut = tanh(_e68);
    let _e71: vec4<f32> = a;
    acosOut = acos(_e71);
    let _e74: vec4<f32> = a;
    asinOut = asin(_e74);
    let _e77: vec4<f32> = a;
    logOut = log(_e77);
    let _e80: vec4<f32> = a;
    log2Out = log2(_e80);
    let _e83: vec4<f32> = a;
    lengthOut = length(_e83);
    let _e86: mat4x4<f32> = m;
    determinantOut = determinant(_e86);
    let _e89: i32 = i;
    bitCountOut = countOneBits(_e89);
    let _e92: i32 = i;
    bitfieldReverseOut = reverseBits(_e92);
    let _e95: vec4<f32> = a;
    atanOut = atan(_e95.x);
    let _e99: vec4<f32> = a;
    let _e101: vec4<f32> = a;
    atan2Out = atan2(_e99.x, _e101.y);
    let _e105: vec4<f32> = a;
    let _e107: vec4<f32> = b;
    modOut = (_e105.x % _e107.x);
    let _e111: vec4<f32> = a;
    let _e112: vec4<f32> = b;
    powOut = pow(_e111, _e112);
    let _e115: vec4<f32> = a;
    let _e116: vec4<f32> = b;
    dotOut = dot(_e115, _e116);
    let _e119: vec4<f32> = a;
    let _e120: vec4<f32> = b;
    maxOut = max(_e119, _e120);
    let _e123: vec4<f32> = a;
    let _e124: vec4<f32> = b;
    minOut = min(_e123, _e124);
    let _e127: vec4<f32> = a;
    let _e128: vec4<f32> = b;
    reflectOut = reflect(_e127, _e128);
    let _e131: vec4<f32> = a;
    let _e133: vec4<f32> = b;
    crossOut = cross(_e131.xyz, _e133.xyz);
    let _e137: vec4<f32> = a;
    let _e138: vec4<f32> = b;
    outerProductOut = outerProduct(_e137, _e138);
    let _e141: vec4<f32> = a;
    let _e142: vec4<f32> = b;
    distanceOut = distance(_e141, _e142);
    let _e145: vec4<f32> = a;
    let _e146: vec4<f32> = b;
    stepOut = step(_e145, _e146);
    return;
}

[[stage(vertex)]]
fn main() {
    main1();
    return;
}
